<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>49-属性和方法的查找顺序</title>
</head>
<body>
<script>
    // 定义了一个构造函数
    function Person(name, age) {
        this.name = name;
        this.age = age;
        // this.type = "人";
        // this.say = function () {
        //     console.log("自己的", this.name, this.age);
        // }
    }
    // 给构造函数的原型对象添加属性和方法
    // Person.prototype.say = function () {
    //     console.log("原型的",this.name, this.age);
    // };
    Person.prototype.type = "超人";

    // 通过构造函数创建对象
    var obj1 = new Person("lnj", 13);
    // 会先在当前对象中查找有没有type属性, 如果有, 使用当前的
    // 如果当前对象没有type属性, 会到原型对象中查找, 如果有, 就使用原型对象中的type属性
    // 如果原型对象中没有, 会继续根据__proto__链条查找, 如果找到null都没有, 就输出undefined
    // console.log(obj1.type);

    // 会先在当前对象中查找有没有say方法, 如果有, 使用当前的
    // 如果当前对象没有say方法, 会到原型对象中查找, 如果有, 就使用原型对象中的say方法
    // 如果原型对象中没有, 会继续根据__proto__链条查找, 如果找到null都没有, 就报错
    // obj1.say();

    console.log(obj1.__proto__.type);
    // 注意点:
    // 在直接通过对象访问属性的时, 不会修改原型中的属性
    // 会在当前对象中新增一个属性
    obj1.type = "人";
    // obj1.__proto__.type = "人";
    console.log(obj1.__proto__.type); // 超人

</script>
</body>
</html>